                     Цепочка вызовов
Прежде чем мы продолжим знакомиться с другими методами строк, давайте сперва узнаем, что методы можно 
вызывать цепочкой. Для этого можно использовать следующий шаблон

        объект.название_метода_1().название_метода_2()
Вот взгляните на пример ниже:

            spell = 'AbracAdAbra'
            print(spell.swapcase().replace('A', 'O'))  # aBROCaDaBRO
Сперва мы вызываем метод .swapcase, он создает новую строку, в которой каждый символ имеет противоположный 
регистр относительно строки в переменной spell. А затем в полученном результате мы заменяем букву А на букву О.


Будьте аккуратны, создавая цепочки вызовов. Все примеры выше работали корректно, поскольку каждый метод возвращал 
в качестве результата новую строку. Но некоторые методы могут возвращать другой тип данных, например, 
метод index возвращает целое число. Если попытаться вызвать метод строки у числа, вы получите ошибку AttributeError.

В примере ниже показан как раз такой случай
    a = 100
    print(a.title())  # AttributeError: 'int' object has no attribute 'title'
Вот почему в этой цепочке вызовов
    s = 'Linkin park'
    print(s.index('i'))
    print(s.index('i').upper())  # AttributeError: 'int' object has no attribute 'upper'
вы увидите ошибку
    AttributeError: 'int' object has no attribute 'upper'



Метод startswith
    Метод .startswith  (с английского «starts with» дословно переводится как «начинаться с») позволяет проверить, начинается ли строка с определенной подстроки (префикса). Он имеет следующий шаблон вызова:

    S.startswith(prefix[, start[, end]])
    Может принимать от одного до трех аргументов при вызове и, следовательно, имеет три варианта вызова.

    Рассмотрим первый из них:

    S.startswith(prefix)
    Метод .startswith возвращает True, если строка S начинается с последовательности символов prefix (префикса) и False в противном случае. Вот несколько примеров:

    s = 'Мила Кунис'
    print(s.startswith('Мила'))  # True
    print(s.startswith('М'))  # True
    print(s.startswith('Бред'))  # False
    print(s.startswith('мила'))  # False
    print(s.startswith('м'))  # False
    print(s.startswith('Мила Кунис'))  # True

Второй вариант вызова
    S.startswith(prefix, start)
предполагает помимо строки-префикса указать стартовую позицию для проверки.
    s = 'Мила Кунис'
    print(s.startswith('Мила', 1))  # False
    print(s.startswith('ила', 1))  # True
    print(s.startswith('ла', 1))  # False
    print(s.startswith('ла', 2))  # True

И последний вариант вызова
    S.startswith(prefix, start, end)
позволяет указать значение  end - индекс, ограничивающий позицию проверки. Значение end не включается в диапазон проверки, учитывайте это.
    s = 'Мила Кунис'
    print(s.startswith('ил', 1, 2))  # False
    print(s.startswith('ил', 1, 3))  # True
    print(s.startswith('Мила', 0, 3))  # False
    print(s.startswith('Мила', 0, 4))  # True



Метод .endswith (с английского «ends with» дословно переводится как «заканчиваться чем-то») позволяет проверить, заканчивается ли строка 
определенной подстрокой. Данный метод имеет следующий шаблон вызова:
    S.endswith(prefix[, start[, end]])

Он также как и метод .startswith обязательно принимает строку prefix и может принимать два необязательных значения для ограничения 
позиций проверки.
Следовательно, вариант вызова
    S.endswith(prefix)
вернет True, если строка S заканчивается последовательностью символов prefix, и False в противном случае.
    Вот несколько примеров:

    s = 'Мила Кунис'
    print(s.endswith('Кунис'))  # True
    print(s.endswith('с'))  # True
    print(s.endswith('Бред'))  # False
    print(s.endswith('Мила'))  # False
    print(s.endswith('кунис'))  # False
    print(s.endswith('Мила Кунис'))  # True

Вариант вызова
    S.endswith(prefix, start)
    позволит ограничить начало поиска. Взгляните на примеры ниже:

    s = 'Мила Кунис'
    print(s.endswith('нис', 10))  # False
    print(s.endswith('нис', 7))  # True
    print(s.endswith('нис', -3))  # True

    print(s.endswith('Кунис', 5))  # True
    print(s.endswith('Кунис', 6))  # False

Сама позиция start включается в проверках. Чего нельзя сказать про аргумент end. Если его передать, он, 
как всегда, выпадет из проверки:
    s = 'Мила Кунис'
    print(s.endswith('ис', 8, 9))  # False
    print(s.endswith('ис', 8, 10))  # True

    print(s.endswith('Кунис', 5, 8))  # False
    print(s.endswith('Кунис', 5, 9))  # False
    print(s.endswith('Кунис', 5, 10))  # True




                        Методы строк
В этом уроке познакомимся с тремя методами, которые позволят расширить строку до определенной длины, дополнив при этом 
ее определенными символами. В этом нам помогут следующие методы:
   ➖ .ljust 
   ➖ .rjust 
   ➖ .center 
   ➖ .zfill


                        Метод ljust
Метод .ljust  имеет следующий шаблон вызова:
    S.ljust(width[, fillchar])
Метод  .ljust принимает один обязательный параметр width - ширину строки и один необязательный параметр 
fillchar - знак заполнителя (по умолчанию пробел).

Метод  .ljust создаст новую строку, в которой исходная строка S прижмется к левой стороне, а
справа она будет дополнена символами fillchar до указанной длины width.
    d = 'Coldplay'
    print(d.ljust(11))  # 'Coldplay   '
    print(d.ljust(11, '-'))  # Coldplay---
    print(d.ljust(11, '&'))  # Coldplay&&&

Если параметр width меньше длины строки, то будет возвращена исходная строка без изменений:
    d = 'Coldplay'
    print(d.ljust(5, '!'))  # Coldplay

В параметр fillchar можно передать только строку, состоящую из одного символа. Если передать пустую строку или
более одного символа, произойдет ошибка
    TypeError: The fill character must be exactly one character long

Вот пример такой ситуации
    d = 'Coldplay'
    print(d.ljust(5, ''))  # TypeError: The fill character must be exactly one character long

Метод rjust
Метод .rjust  имеет следующий шаблон вызова:
    S.rjust(width[, fillchar])
Метод .rjust принимает один обязательный параметр width - ширину строки и один необязательный параметр 
fillchar - знак заполнителя (по умолчанию пробел) . Возвращает новую строку, в которой исходная строка 
S дополнена слева символами fillchar до указанной длины width. Если параметр width меньше длины строки, 
то будет возвращена исходная строка без изменений:

    d = 'qwerty'
    print(d.rjust(10))
    print(d.rjust(10, '-'))
    print(d.rjust(10, '&'))
    print(d.rjust(5, '!'))

    out
        qwerty
    ----qwerty
    &&&&qwerty
    qwerty

                Метод center
Метод .center  имеет следующий шаблон вызова:
    S.center(width[, fillchar])
Метод .center принимает один обязательный параметр width - ширину строки и один необязательный параметр 
    fillchar - знак заполнителя (по умолчанию пробел) . Возвращает новую строку длиной width, в которой исходная 
    строка S находится в центре, а справа и слева от нее находятся символы fillchar . Если параметр width меньше 
    длины строки, то будет возвращена исходная строка без изменений. 

В параметр fillchar также можно передать только строку, состоящую из одного символа. В случаях, когда количество 
необходимых для дополнения символов нечетно, слева будет на один символ fillchar больше, чем справа.


                Метод zfill
Метод .zfill  имеет следующий шаблон вызова:
    S.zfill(width)
Метод .zfill возвращает новую строку, в которой исходная строка S дополнена нулями слева так, чтобы длина новой строки 
стала равна width.
