                                        Методы списков

практически каждый вызов метода списка будет изменять состояние самого списка без явного присваивания.

У списков есть три метода, позволяющих выполнить добавление новых элементов, их имена:
   ✔️  append;
   ✔️  insert;
   ✔️  extend.

                            Метод append
Первый метод, с которым мы познакомимся, называется .append. Он имеет следующий шаблон вызова:
        L.append(x)
Метод .append обязательно принимает одно значение x и добавляет его в качестве нового элемента  в конец списка L.
После вызова метода .append размер списка увеличивается на одно значение. Никакого присвоения делать не нужно

Повторюсь, метод append используется без присваивания. Если вы попробуете сохранить результат работы метода .append 
в ту же переменную, где находился список, вы потеряете все значения, поскольку метод .append возвращает значение None.
    nums = [34, 23, 12, 15]
    print(nums)  # [34, 23, 12, 15]
    nums = nums.append(22)
    print(nums)  # None


    names = ['Carlos', 'Joshua', 'Alex', 'Kermit', 'Norman']
    names.append(['Eric', 'Felix'])
    print(names) #['Carlos', 'Joshua', 'Alex', 'Kermit', 'Norman', ['Eric', 'Felix']]
    

    names = ['Carlos', 'Joshua', 'Alex', 'Kermit', 'Norman']
    names = names.append('Eric')
    names = names.append('Felix')
    print(names) #Будет ошибка AttributeError Во 2й строке в переменную names запишется значение None. В третьей строке мы 
                 #уже будем вызывать метод append не у списка, а у значения None. А у None нету такого метода

За один вызов метода  .append вы можете добавить только одно любое значение: это может быть строка, число или даже список. Но ни в коем случае нельзя передавать больше одного значения в один вызов, возникнет ошибка TypeError:
    nums = [34, 23, 12, 15]
    print(nums)  # [34, 23, 12, 15]
    nums.append(22, 23, 24)  # TypeError: list.append() takes exactly one argument (3 given)
    print(nums)


    nums = [34, 23, 12, 15]
    print(nums)  # [34, 23, 12, 15]
    nums.append(22)
    nums.append(23)
    nums.append(24)
    print(nums)  # [34, 23, 12, 15, 22, 23, 24]


                            Метод insert
Метод .append может добавить новый элемент только в конец вашего списка, на другие позиции он этого сделать не сможет. 
Если вам потребуется добавить новое значение в произвольный индекс вашего списка, вам нужен метод .insert. Он имеет 
следующий формат:
    L.insert(index, value)
Метод .insert выполняет вставку нового значения в список на определенную позицию. Метод .insert должен принимать два 
значения: index  - индекс куда вставляем новое значение и value - что нужно ставить, то есть само значение. Новое значение 
помещается в список по индексу index, размер списка увеличивается на единицу. При этом происходит смещение всех элементов 
вправо, начиная с позиции index, для вставки нового значения value.

Мы хотим поместить новое значение на первый индекс. Для этого нужно сделать три вещи:
  1️⃣ увеличиваем размер списка на единицу;
  2️⃣ смещаем все элементы с 1го индекса вправо, значит, двигаются значения 23, 12 и 15
  3️⃣ записываем новое значение в 1й индекс.
Вызов метода .insert меняет состояние самого списка. Не нужно использовать присваивание.

    fruits = ['apple', 'banana', 'cherry', 'orange']
    fruits.insert(0, 'mango')
    print(fruits)  # ['mango', 'apple', 'banana', 'cherry', 'orange']


Если указать индекс, который выходит за пределы списка, то элемент будет добавлен в конец списка:

    fruits = ['apple', 'banana', 'cherry', 'orange']
    fruits.insert(15, 'mango')
    print(fruits)  # ['apple', 'banana', 'cherry', 'orange', 'mango']

Если указать отрицательный индекс, который также выйдет за пределы допустимых индексов текущего списка, произойдет вставка в начало списка:

    fruits = ['apple', 'banana', 'cherry', 'orange']
    fruits.insert(-9, 'mango')
    print(fruits)  # ['mango', 'apple', 'banana', 'cherry', 'orange']


                                Метод extend
Рассмотрим еще один метод, который позволяет добавлять элементы в список, причем делать этого массово. 
Он называется  .extend и переводится как «расширять». Данный метод имеет следующий формат:
        L.extend(iterable)
Метод .extend принимает обязательно один аргумент - итерируемую последовательность.
Здесь нам придется забежать немного вперед, потому что данную тему мы еще не разбирали. 
Итерируемая последовательность состоит из нескольких элементов, поэтому списки и строки являются такой последовательностью.

При помощи метода .extend можно добавить сразу все элементы из итерируемой последовательности в конец списка L. 
Значит, метод .extend позволяет добавлять за один раз множество элементов , вот его отличие от метода .append
    nums = [34, 23, 12, 15]
    print(nums)  # [34, 23, 12, 15]
    nums.extend([10, 40, 30])
    print(nums)  # [34, 23, 12, 15, 10, 40, 30]



    names = ['Carlos', 'Joshua', 'Alex', 'Kermit']
    names.extend('Norman')
    print(names) #['Carlos', 'Joshua', 'Alex', 'Kermit', 'N', 'o', 'r', 'm', 'a', 'n']


                                            Удаление элементов
Раз мы можем добавлять элементы в список, то, значит, есть возможность и удалять элементы из списка. 
За удаление отвечают три метода, которые называются:
   ✔️  clear;
   ✔️  pop;
   ✔️  remove.


                                            Метод clear
Самым простым методом в использовании является clear, он позволяет полностью очистить список от значений. 
Имеет следующий формат вызова:
        L.clear()
Метод .clear не принимает никаких аргументов и делает список L пустым, удаляя все его элементы. 
    nums = [34, 23, 12, 15]
    print(nums)  # [34, 23, 12, 15]
    nums.clear()
    print(nums)  # []

    fruits = ['apple', 'banana', 'cherry', 'orange']
    fruits.clear()
    print(fruits)  # []


                                        Метод pop
Очень полезный метод .pop. Он имеет следующий формат вызова:
    L.pop([index])	
Метод .pop делает две вещи: возвращает значение элемента с индексом index, а также удаляет его из списка L.
По сути метод выполняет изъятие из списка элемента, стоящего на позиции index.
    Вот пример:

    nums = [34, 23, 12, 15]
    print(nums)  # [34, 23, 12, 15]
    nums.pop(1)
    print(nums)  # [34, 12, 15]
    nums.pop(2)
    print(nums)  # [34, 12]    

Сам параметр index является необязательным во время вызова метода .pop. Если его не передавать, по умолчанию он будет равен -1,  и, значит, изъятие будет происходить с последним элементом списка. 
Взгляните, как после каждого вызова будет исчезать последний элемент списка:
    fruits = ['apple', 'banana', 'cherry', 'orange']
    print(fruits)  # ['apple', 'banana', 'cherry', 'orange']
    fruits.pop()
    print(fruits)  # ['apple', 'banana', 'cherry']
    fruits.pop()
    print(fruits)  # ['apple', 'banana']

Если попытаться удалить несуществующий индекс при помощи метода .pop, возникнет исключение
IndexError: pop index out of range



                        Метод remove
Метод .remove имеет следующий формат:
    L.remove(x)
 Слово remove переводится как «удалить», но этот метод, в отличие от метода .pop, удаляет по значению. 
 Вы должны обязательно передать одно значение x.

  Метод .remove производит удаление первого найденного элемента, значение которого равно x, из списка L. 
Длина списка уменьшается на единицу, элементы, стоящие справа от удаленного, смещаются влево на одну позицию.
    nums = [34, 23, 12, 15]
    print(nums)  # [34, 23, 12, 15]
    nums.remove(23)
    print(nums)  # [34, 12, 15] 


    Если в списке L есть несколько элементов равных значению x, удалится только первый найденный слева элемент. За один вызов метода удаляется один элемент. 
Если нужно удалить несколько элементов, то несколько раз вызывайте метод .remove

    Метод .remove выбросит ошибку ValueError, если значение x не будет найдено в списке L.

    Traceback (most recent call last):
    File "/tmp/sessions/0846798beac2cd1c/main.py", line 6, in <module>
        a.remove(34)
    ValueError: list.remove(x): x not in list



                            Метод copy
У списков есть метод, который позволяет сделать копию. Называется он аналогично .copy и имеет следующий формат вызова:
    L.copy()
Метод .copy не принимает аргументов, делает копию списка - создается совершенно новый объект в памяти, он тоже является 
списком и будет состоять из таких же элементов, как и оригинальный список, но у нового списка будет другой идентификатор 
в памяти.
    a = [34, 23, 12, 28, 9, 15]
    b = a.copy()
    print(a)  # [34, 23, 12, 28, 9, 15]
    print(b)  # [34, 23, 12, 28, 9, 15]
    print(id(a), id(b))  # разные идентификаторы


    Метод .copy делает поверхностную копию, это значит,  он не делает копию вложенных списков, 
если они есть, только элементов основного списка.

!!!!!!    При поверхностном копировании не создаются копии у вложенных объектов, поэтому изменения в одной 
переменной будут влиять и на другие.!!!!!

    a = [34, 23, [12, 28, 9], 15]
    b = a.copy()
    print(a)  # [34, 23, [12, 28, 9], 15]
    print(b)  # [34, 23, [12, 28, 9], 15]

    print('-' * 10)

    a[0] = 3
    a[2][1] = 100
    a[2][0] = 77
    print(a)  # [3, 23, [77, 100, 9], 15]
    print(b)  # [34, 23, [77, 100, 9], 15]


    Помимо поверхностного копирования в python есть еще и полное. Оно реализуется за счет функции deepcopy, которая находится во встроенном модуле copy. Изучение 
встроенных модулей выходит за рамки нашего курса, поэтому я оставлю в комментариях к этому уроку информацию о том, как сделать полное копирование.




                                Метод count
У списка в арсенале имеется метод, который позволяет подсчитать, какое количество раз в нем встречается определенное значение. 
Метод называется .count и имеет следующий формат:
    L.count(x)
Принимает обязательно один аргумент. При помощи метода .count можно посчитать, сколько раз встретилось в списке переданное 
значение x. Вот взгляните на примеры:
    a = [34, 23, 12, 28, 9, 15, 23, 2, 23]
    print(f'23 встречается {a.count(23)} раз')
    print(f'12 встречается {a.count(12)} раз')
    print(f'24 встречается {a.count(24)} раз')




                Метод index
У списков имеется метод .index, который работает аналогичным образом, как и у строк. Он имеет следующий формат:
            L.index(x, [start [, end]])
Метод .index находит переданный элемент x в списке L и возвращает его индекс. Если в списке находится несколько 
элементов,  равных значению x, то будет возвращен индекс первого из них. Если список не содержит переданный элемент x, 
будет вызвано исключение ValueError.  У метода есть необязательные параметры start и end :

    Если задан индекс start, то первое вхождение значения x будет искаться начиная с индекса start;
 
    Если заданы индексы start и end, то первое вхождение значения x будет искаться начиная с индекса start и до индекса end.  Индекс start включается, а индекс end не включается.

    a = [34, 23, 12, 28, 23, 2, 23]

    print(a.index(23))  # 1
    print(a.index(12))  # 2
    print(a.index(23, 1))  # 1
    print(a.index(23, 2))  # 4
    print(a.index(23, 2, 5))  # 4



                                        Метод reverse
    Метод .reverse позволяет поменять порядок следования элементов в списке на противоположный: 
первый элемент окажется последним, второй - предпоследним и т.д. Данный метод имеет следующий формат:
    L.reverse()
Метод .reverse  не требует никаких аргументов и выполняет разворот списка - располагает элементы в противоположном порядке.

    a = [34, 23, 12, 28, 23]
    a.reverse()
    print(a)  # [23, 28, 12, 23, 34]

При повторном вызове список вернётся в изначальное положение.

    a = [34, 23, 12, 28, 23]
    a.reverse()
    print(a)  # [23, 28, 12, 23, 34]
    a.reverse()
    print(a)  # [34, 23, 12, 28, 23]



                                Метод sort
Cамый, наверное, популярный метод списков - это .sort. Он выполняет сортировку. Имеет следующий формат:
    L.sort(key=None, reverse=False)
Если не передать никаких аргументов, то по умолчанию сортировка будет выполнена по возрастанию.
    nums = [34, 23, 12, 15]
    nums.sort()
    print(nums)  # [12, 15, 23, 34]
После этого можете вызвать метод .reverse. Список отсортируется по убыванию.
    nums = [34, 23, 12, 15]
    nums.sort()
    print(nums)  # [12, 15, 23, 34]
    nums.reverse()
    print(nums)  # [34, 23, 15, 12]
Если вы сразу хотите его отсортировать по убыванию, то вы можете вызвать метод .sort и в нём внутри скобок 
дополнительно прописать reverse=True.
    nums = [34, 23, 12, 15]
    nums.sort(reverse=True)
    print(nums)  # [34, 23, 15, 12]




    Важно, чтобы список состоял из элементов, которые могут сравниваться между собой. Например, список строк может быть отсортирован, 
поскольку строки между собой умеют сравниваться
    fruits = ['orange', 'banana', 'apple', 'cherry']
    fruits.sort()
    print(fruits)  # ['apple', 'banana', 'cherry', 'orange']

    Но если попробовать отсортировать список, состоящий из строк и чисел, возникнет ошибка
TypeError: '<' not supported between instances of 'str' and 'int'
как в примере ниже
    values = [34, 'banana', 'apple', 15]
    values.sort()  # TypeError: '<' not supported between instances of 'str' and 'int'
    print(values)


