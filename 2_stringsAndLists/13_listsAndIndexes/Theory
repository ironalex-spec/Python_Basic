                Списки: индексы и срезы
В разделе «2.3 Строки: индексы и срезы» мы познакомились с понятиями «индекс» и «срез». В этом уроке мы увидим, 
что списки, также как и строки, умеют работать с индексами и со срезами. Операции обращения по индексу и взятия среза у 
списков будут выполняться в точности так же, как и у строк. Взгляните сами. 

    Обращение по индексу
Список представляет собой упорядоченную коллекцию элементов

Слово «упорядоченный» в этом определении означает, что каждый элемент располагается на своём конкретном месте и, следовательно, 
имеет свой индекс. Нумерация индексов начинается с нуля с левого края. Также имеется отрицательная нумерация, которая начинается 
с правого края списка (с последнего элемента) со значения -1 и идет в сторону уменьшения. Все как у строк. 

Значит, если взять в качестве примера следующий список a
    0 1 2 3 4 5
a = [34, 23, 12, 28, 9, 15]
    -6 -5 -4 -3 -2 -1

Зная индекс элемента, можно получить его значение через операцию обращения по индексу. Она осуществляется по следующему формату:
    список[индекс]

Вы обращаетесь к списку и далее в квадратных скобках указываете индекс. Вот взгляните на несколько примеров обращения по индексу:
    a = [34, 23, 12, 28, 9, 15]
    print(a[0])  # => 34
    print(a[2])  # => 12
    print(a[4])  # => 9

    print(a[-1])  # => 15
    print(a[-3])  # => 28

Не допускается обращаться к несуществующему индексу списка. Если вы обратитесь по индексу, который отсутствует в 
данном списке, вы столкнетесь с ошибкой IndexError.

        Срезы
Для списков используется аналогичный со строками синтаксис взятия среза, вот как он выглядит:
    список[start:stop]
где используются следующие обозначения:
 ➖ start - это индекс позиции (включительно), начиная с которой нужно брать срез;
 ➖ stop - это индекс позиции (не включительно), на которой необходимо закончить взятие среза.

вот несколько примеров, где мы берем срезы для списка notes:

    notes = ['До', 'Ре', 'Ми', 'Фа', 'Соль', 'Ля', 'Си']

    print(notes[1:3])  # ['Ре', 'Ми']
    print(notes[4:6])  # ['Соль', 'Ля']
    print(notes[-3:-1])  # ['Соль', 'Ля']
    print(notes[0:5])  # ['До', 'Ре', 'Ми', 'Фа', 'Соль']

Также допускается оставлять один из параметров start/stop не заполненным. Если оставить start пустым, будут браться все элементы с начала списка; если оставить пустым stop, то срез возьмется автоматически до конца списка.

    notes = ['До', 'Ре', 'Ми', 'Фа', 'Соль', 'Ля', 'Си']

    print(notes[:2])  # ['До', 'Ре']
    print(notes[4:])  # ['Соль', 'Ля', 'Си']
    print(notes[:-3])  # ['До', 'Ре', 'Ми', 'Фа']
    Если оставить оба параметра start и stop пустыми, срез возьмется по всему списку от начала до конца:

    notes = ['До', 'Ре', 'Ми', 'Фа', 'Соль', 'Ля', 'Си']

    print(notes[:])  # ['До', 'Ре', 'Ми', 'Фа', 'Соль', 'Ля', 'Си']


Причем операция notes[:] создаст совершенно новый список, у которого будут те же элементы, что и у списка notes. Другими словами, операция notes[:] 
позволяет создать копию списка. В том, что создается именно копия, легко убедиться, если взглянуть на идентификаторы этих переменных, они будут разные
    notes = ['До', 'Ре', 'Ми', 'Фа', 'Соль', 'Ля', 'Си']
    copy_notes = notes[:]
    print(id(notes))
    print(id(copy_notes))

При срезах допускается указывать несуществующие индексы, ошибки IndexError в таком случае не будет
    notes = ['До', 'Ре', 'Ми', 'Фа', 'Соль', 'Ля', 'Си']
    print(notes[4:45])  # ['Соль', 'Ля', 'Си']
В примере выше взялись элементы по максимально существующий индекс. По сути операция notes[4:45] в данном случае аналогична операции 
notes[4:].



При взятии среза допускается использовать еще один дополнительный параметр - шаг. В тексте ниже он обозначен через слово step
    ​список[start:stop:step]
Шаг среза влияет на расстояние между объектами, которые попадут в итоговый срез. По умолчанию шаг равен единице, тем самым б
ерется каждый первый элемент. Поэтому запись
    notes[4:6]
аналогична записи
    notes[4:6:1]
Вот несколько примеров, где мы берем срез с нестандартным шагом
    notes = ['До', 'Ре', 'Ми', 'Фа', 'Соль', 'Ля', 'Си']
    print(notes[2:6:2])  # ['Ми', 'Соль']
    print(notes[::2])  # ['До', 'Ми', 'Соль', 'Си']
    print(notes[1::2])  # ['Ре', 'Фа', 'Ля']
    print(notes[::3])  # ['До', 'Фа', 'Си']

А вот примеры, где берется отрицательное значение шага с целью смены направления взятия элементов:
    notes = ['До', 'Ре', 'Ми', 'Фа', 'Соль', 'Ля', 'Си']
    print(notes[6:2])  # []
    print(notes[6:2:-1])  # ['Си', 'Ля', 'Соль', 'Фа']
    print(notes[6:2:-2])  # ['Си', 'Соль']
    print(notes[::-1])  # ['Си', 'Ля', 'Соль', 'Фа', 'Ми', 'Ре', 'До']
    print(notes[::-3])  # ['Си', 'Фа', 'До']


                            Изменяемость списка
И вот мы приходим к главному отличию списка от строки, оно заключается в том, что список, в отличие от строки, 
является изменяемым объектом. Это означает, что вы можете в уже созданном объекте заменять элементы. Строки такого себе 
не позволяли. Помните? Когда мы пытались присвоить по индексу строки новый символ

Со списками такой трюк пройдет: вы без проблем можете заменить элемент новым значением по индексу. Вот взгляните:

    notes = ['До', 'Ре', 'Ми', 'Фа', 'Соль', 'Ля', 'Си']

    print(notes)  # ['До', 'Ре', 'Ми', 'Фа', 'Соль', 'Ля', 'Си']
    notes[3] = 'Бо'
    notes[4] = 'Бы'
    print(notes)  # ['До', 'Ре', 'Ми', 'Бо', 'Бы', 'Ля', 'Си']


Более того, вы можете заменять элементы в списке срезами. Замену можно делать на равное количество элементов (в примере ниже заменяем два элемента в срезе на два новых элемента)
    notes = ['До', 'Ре', 'Ми', 'Фа', 'Соль', 'Ля', 'Си']

    print(notes)  # ['До', 'Ре', 'Ми', 'Фа', 'Соль', 'Ля', 'Си']
    notes[3:5] = ['Бо', 'Бы']
    print(notes)  # ['До', 'Ре', 'Ми', 'Бо', 'Бы', 'Ля', 'Си']


или неравное количество
    notes = ['До', 'Ре', 'Ми', 'Фа', 'Соль', 'Ля', 'Си']
    print(notes)  # ['До', 'Ре', 'Ми', 'Фа', 'Соль', 'Ля', 'Си']
    notes[1:5] = ['Бо', 'Бы']
    print(notes)  # ['До', 'Бо', 'Бы', 'Ля', 'Си']

В примере выше мы заменили 4-ре элемента среза на список из двух значений.

Помимо изменения элементов можно выполнять и явное удаление. 
Оператор del поможет вам избавиться от ненужного элемента при помощи следующего синтаксиса
    del список[индекс]
или сразу от нескольких элементов через срез таким образом:
    del список[старт:стоп]

    Вот взгляните на пример по элементного удаления:

    notes = ['До', 'Ре', 'Ми', 'Фа', 'Соль', 'Ля', 'Си']

    print(notes)  # ['До', 'Ре', 'Ми', 'Фа', 'Соль', 'Ля', 'Си']
    del notes[1]
    print(notes)  # ['До', 'Ми', 'Фа', 'Соль', 'Ля', 'Си']
    del notes[1]
    print(notes)  # ['До', 'Фа', 'Соль', 'Ля', 'Си']


    А вот удаление сразу группы элементов:
    notes = ['До', 'Ре', 'Ми', 'Фа', 'Соль', 'Ля', 'Си']

    print(notes)  # ['До', 'Ре', 'Ми', 'Фа', 'Соль', 'Ля', 'Си']
    del notes[1:5]
    print(notes)  # ['До', 'Ля', 'Си']


                        Особенность изменяемых объектов
Обратите особое внимание на информацию это подраздела. Она поможет избежать в будущем множества ошибок при работе с 
изменяемыми объектами.
            a = [1, 2, 3]
            b = a
            print(a)  # [1, 2, 3]
            print(b)  # [1, 2, 3]

            print('-' * 10)

            b[0] = 10
            print(a)  # [10, 2, 3]
            print(b)  # [10, 2, 3]

Давайте вспомним, что именно хранит в себе переменная. В ней хранится ссылка на объект. Когда вы присваиваете одну 
переменную в другую, то копируется не сам объект, а ссылка на него. Тем самым создается разделяемая или общая ссылка: 
когда несколько переменных ссылаются на один и тот же объект. Теперь к этому добавим знание того, что список является 
изменяемым объектом. И получается, что любое изменение, которое вы сделаете через a или b, затронет первоначальный объект 
списка. Ниже представлено схематичное объяснение происходящего

Чтобы избежать такой ситуации, вы должны будете сделать копию списка при помощи среза всех элементов, тем самым создатся 
точно такой же список, но занимающий другую ячейку памяти. То есть у вас будут два разных списка. И тогда изменения одного 
объекта не будут влиять на изменение другого. Вот взгляните на пример:
    a = [1, 2, 3]
    b = a[:]  # создаем копию списка
    print(a)  # [1, 2, 3]
    print(b)  # [1, 2, 3]


    b[0] = 10
    print(a)  # [1, 2, 3]
    print(b)  # [10, 2, 3]

    a[0] = 111
    print(a)  # [111, 2, 3]
    print(b)  # [10, 2, 3]